<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2304979176656635" crossorigin="anonymous"></script><meta name="generator" content="Jekyll v4.3.4" /><meta property="og:title" content="WebRTC Video Chat 만들기" /><meta property="og:locale" content="en_US" /><meta name="description" content="created : 2021-11-15, updated : 2021-11-15" /><meta property="og:description" content="created : 2021-11-15, updated : 2021-11-15" /><link rel="canonical" href="https://ahnchan.github.io/posts/WebRTC-basic/" /><meta property="og:url" content="https://ahnchan.github.io/posts/WebRTC-basic/" /><meta property="og:site_name" content="Ahnchan" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-15T16:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="WebRTC Video Chat 만들기" /><meta name="twitter:site" content="@claude_ahn" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-11-18T08:41:44+09:00","datePublished":"2021-11-15T16:00:00+09:00","description":"created : 2021-11-15, updated : 2021-11-15","headline":"WebRTC Video Chat 만들기","mainEntityOfPage":{"@type":"WebPage","@id":"https://ahnchan.github.io/posts/WebRTC-basic/"},"url":"https://ahnchan.github.io/posts/WebRTC-basic/"}</script><title>WebRTC Video Chat 만들기 | Ahnchan</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Ahnchan"><meta name="application-name" content="Ahnchan"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-JLF9MP8SLS"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-JLF9MP8SLS'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div class="site-title mt-3"> <a href="/">Ahnchan</a></div><div class="site-subtitle font-italic">The Infinity To Beyond!</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/ahnchan" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/claude_ahn" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['ahnchan','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>WebRTC Video Chat 만들기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>WebRTC Video Chat 만들기</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Chanyoung Ahn </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Mon, Nov 15, 2021, 4:00 PM +0900" prep="on" > Nov 15, 2021 <i class="unloaded">2021-11-15T16:00:00+09:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Nov 18, 2021, 8:41 AM +0900" prefix="Updated " > Nov 18, 2021 <i class="unloaded">2021-11-18T08:41:44+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3371 words">18 min</span></div></div><div class="post-content"><p>created : 2021-11-15, updated : 2021-11-15</p><h1 id="introduction">Introduction</h1><p>WebRTC는 Device간의 Video, Audio와 Data까지 Peer to Peer로 통신을 할 수 있게 한다. 통신환경이 좋아져서 적은 사용자의 커넥션에서는 WebRTC가 중간 Streaming 서버 없이도 Device의 자원, 인터넷속도로도 Video/Audio 의 통신이 가능하다. 심지어는 모바일 에서도 가능하다. Android, iOS등 모바일 뿐 아니라 웹 브라우져에서도 가능하여 손쉽게 서비스를 개발할 수 있다.</p><blockquote><p>Note. 본 튜토리얼은 OReiliy 의 Video 강의인 “<a href="https://learning.oreilly.com/videos/practical-webrtc-a/9781801810012/">Practical WebRTC: A Complete WebRTC Bootcamp for Beginners</a>“을 듣고 코드로 구현한 것이다. 좀더 자세한 내용을 원하면 해당 강의를 듣기를 권장한다.</p></blockquote><p>좀더 이론적인 부분과 컨셉은 <a href="https://webrtc.org/getting-started/overview?hl=en">WebRTC 공식 문서</a>를 확인하면 좋겠다.</p><h1 id="pre-installation">Pre-Installation</h1><p>Node.js</p><blockquote><p>Note. 튜토리얼의 소스는 <a href="https://github.com/ahnchan/tutorial-WebRTC">https://github.com/ahnchan/tutorial-WebRTC</a>에 있다.</p></blockquote><h1 id="concepts">Concepts</h1><p>WebRTC는 기본적으로 Peer To Peer 로 영상, 오디오를 서로 스트리밍을 하는 방식이다. 이를 위해서는 중간에 데이터를 전달하기 위한 Signaling Server와 NAT 환경에서도 사용이 가능하게 해주는 STUN Server, TURN Server가 필요하다. 이런 환경 구성은 NAT 환경에 있는 Client들은 IP로 직접 접속을 할 수가 없기 때문에 이런 서버들이 필요한 것이다.</p><h2 id="signaling-server">Signaling Server</h2><p>접속한 Client들이 정보(Signal)을 주고 받기 위해 사용한다. Client가 STUN Server에서 얻어온 정보인 ICE Candidate 정보와 offer, answer를 서로 교환하기 위해 사용한다. 본 튜토리얼에서는 Node.js에서 socket.io를 이용하여 Signaling Server를 구현해볼 것이다.</p><h2 id="stun-server">STUN Server</h2><p>Client와 Client간 접속을 할 수 있게 하기 위해 서로의 접속할 수 있는 정보(ICE Candidate)를 제공한다. 이 렇게 하는 이유는 NAT 안에 있는 Client에 직접 접속을 할 수 없기 때문이다. NAT 방식에 따라서는 데이터를 relay 해야하는 경우가 있는데 이럴 경우에는 TURN Server를 사용해야한다.</p><h2 id="turn-server">TURN Server</h2><p>Client끼리 통신을 못할 경우에 사용하는 서버로 스트리밍 데이터를 전달해주는 역할을 한다. 이번 튜토리얼에서는 STUN만 사용하도록 하였다.</p><h1 id="signal에-따른-처리-flow">Signal에 따른 처리 Flow</h1><p>간단하게 이번에 구성된 부분의 Signal들의 흐름을 정리해보았다. User A, User B가 ICE Candidate, offer, answer 정보를 Signaling Server 통해서 전달 받도록 되어 있다. 소스를 구성하면 좀 더 이해하기 편할 것이다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/posts/assets/network/images/webrtc-basic-signal-flow.jpg" alt="Signal Flow" width="500" /></p><blockquote><p>Note. candidate는 맨마지막에 전달하는 것은 아니다 offer, answer를 처리하는 중간에 서로 교환이 된다. Flow diagram에서는 표현하기 힘들어 맨 아래에 따로 넣었다.</p></blockquote><blockquote><p>Note. 이 부분은 시그널 명칭은 본인의 마음대로 설정할 수 있고 프로세스도 변경할 수 있다. 이 튜토리얼은 WebRTC를 연결하기 위해 상호 어떤 데이터가 언제 필요한지를 이해하는데 참조하면 좋겠다.</p></blockquote><h1 id="video-chat-project를-만들기">Video Chat Project를 만들기</h1><p>Signaling Server이자 HTML, Javascript 를 Serving할 Project를 만들어 보자.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>$ mkdir videochat
$ cd videchat
$ npm init
…
</pre></table></code></div></div><p>Node.js 서버에서는 express와 socket.io를 사용할 것이다. 프로젝트에 해당 라이브러리를 설치해보자.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>$ npm install --save express socket.io
…
</pre></table></code></div></div><h1 id="server-구성하기">Server 구성하기</h1><p>맨처음 Signal에 대한 Flow에서 표시된 부분에 대해 개발을 한다. Signaling Server는 데이터를 Client간에 통신을 하는 목적이기 때문에 복잡하지는 않다. index.js 파일을 만들고 순서대로 코딩을 해보자.</p><h2 id="필요-라이브러리-선언하기">필요 라이브러리 선언하기</h2><p>프로젝트 초기화하고 npm으로 설치한 express, socket.io를 선언해보자.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>const express = require("express");
const socket = require("socket.io")
</pre></table></code></div></div><p>express 설정 express를 생성하고, 4000 port로 server를 구동한다. 현재는 4000 Port를 express가 열어 놓은 상태이고 아직 어떠한 일도 하지 않는다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>const app = express();

let server = app.listen(4000, function () {
    console.log("Server is running!");
});
</pre></table></code></div></div><h2 id="html-css등-static한-파일을-serving-할수-있게-설정하기">HTML, CSS등 Static한 파일을 Serving 할수 있게 설정하기</h2><p>public 디렉토리를 static 파일의 위치로 선언을 한다. HTTP로 요청오면 모두 이 디렉토리의 파일을 참조하도록 설정을 한 것이다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>app.use(express.static("public"));
</pre></table></code></div></div><h2 id="socketio-설정하기">Socket.io 설정하기</h2><p>socket을 설정하고 접속이 되었을때 접속 socket id를 출력하게 해보자. 브라우저에서 socket.io로 접근을 하면 로그를 찍도록 하였다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>let io = socket(server);

io.on("connection", function (socket) {
    console.log("User connected: " + socket.id);

   // TODO - Signal
}
</pre></table></code></div></div><p>이제 TODO 로 커멘트 되어 있는부분에 Signal들을 구현하면 된다. Signal들의 처리는 간단하다. Signaling Server는 대부분이 Signal들을 접속한 사용자에게 전달하는 역할을 한다.</p><h2 id="join-요청처리하기">join 요청처리하기</h2><p>User가 Room이름을 넣고 Join을 누르면 join 요청을 한다. 서버는 받아서 해당 Room이름이 있는지에 따라 created, joined로 나누어서 답변을 한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>    socket.on("join", function (roomName) {
        let rooms = io.sockets.adapter.rooms;
        let room = rooms.get(roomName);

        if (room == undefined) {
            // create a room
            socket.join(roomName);
            socket.emit("created");
        } else if (room.size == 1) {
            // join
            socket.join(roomName);
            socket.emit("joined");
        } else {
            // Full
            socket.emit("full");
        }

        console.log(rooms);
    });
</pre></table></code></div></div><p>created: Room 이 없는 경우 User에게 “created”를 전달한다. joined: Room이 있는 경우 User에게 “joined” 를 전달한다. full: Room에 인원이 다 채워졌을 경우 User에게 “full”을 전달한다.</p><blockquote><p>Note. 이번 구성은 1:1 접속만 하려고 하여 Room의 인원은 2명을 넘을수 없다.</p></blockquote><h2 id="ready-요청처리하기">ready 요청처리하기</h2><p>두번째 접속하는 User가 joined 명령을 받은 상황에서 준비가 되면 ready 를 보낸다. 그러면 Signaling Server는 Room에 Join된 모든 User에게 ready 신호를 전송한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>    socket.on("ready", function (roomName) { 
        socket.broadcast.to(roomName).emit("ready");
    });
</pre></table></code></div></div><h2 id="candidate-요청처리하기">candidate 요청처리하기</h2><p>WebRTC 접근을 위해서는 상호 ICE Candidate를 전달해야한다. STUN Server나 TURN Server에서 받은 접속정보를 상호 교환하기 위한 부분이다. User에서 ICE candidate 정보를 받으면 서버에 요청하여 Room에 속한 모든 User에게 해당 정보를 보낸다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    socket.on("candidate", function (candidate, roomName) {
        console.log("candidate -------------");
        console.log(candidate);
        socket.broadcast.to(roomName).emit("candidate", candidate);
    });
</pre></table></code></div></div><h2 id="offer-요청처리하기">offer 요청처리하기</h2><p>Room을 생성한 User에서 offer를 생성한 것을 Room의 다른 사용자에게 전달한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    socket.on("offer", function(offer, roomName) {
        console.log("offer -------------");
        console.log(offer);
        socket.broadcast.to(roomName).emit("offer", offer);
    });
</pre></table></code></div></div><h2 id="answer-요청처리하기">answer 요청처리하기</h2><p>Room의 참가자(joined) User에서 answer를 생성한 것을 Room의 다른 사용자에게 전달한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>    socket.on("answer", function(answer, roomName) {
        console.log("answer -------------");
        console.log(answer);        
        socket.broadcast.to(roomName).emit("answer", answer);
    });
</pre></table></code></div></div><blockquote><p>Note. Signaling Server는 User 간에 ICE candidate 정도와 offer, answer을 상황에 맞게 전달하는 역할을 한다.</p></blockquote><h1 id="client-구성하기">Client 구성하기</h1><p>Client는 처음 Room을 만든 생성자와 이후에 접속하는 사용자로 구분하였다. creator라는 변수(Boolean)으로 구분을 하도록 되어 있다. Signal의 구분을 위해서 User A와 User B로 구분해서 작성을 해보겠다. Signal Flow에 명시한 Client의 명칭이랑 동일하다.</p><blockquote><p>Note. 같은 Client코드에 있어서 좀 헷갈릴 수 있기에 생성자, 참가자로 구분을 하였다. 이 용어는 공식적인 명칭은 아니다.</p></blockquote><h2 id="client-화면-구성하기">Client 화면 구성하기</h2><p>public 디렉토리를 만들고, HTML, CSS를 넣을 것이다. 이 부분은 본인의 디자인에 따라 만들면 좋으니 단순히 Git Repository에서 가져다가 사용을 해보자.</p><p>파일: <a href="https://github.com/ahnchan/tutorial-WebRTC/blob/main/public/index.html">index.html</a> 파일: <a href="https://github.com/ahnchan/tutorial-WebRTC/blob/main/public/styles.css">styles.css</a></p><p><a href="https://github.com/ahnchan/tutorial-WebRTC/blob/main/public/chat_init.js">chart_init.js</a> 를 가져와서 chart.js를 만들고 시작을 한다. 이 파일은 기본적인 변수만 지정해 놓았다. 완성된 chart.js는 GIT에 있으니 참조하기 바란다.</p><h2 id="user-a-room-이름을-넣고-join-요청하기">User A. Room 이름을 넣고 Join 요청하기</h2><p>Room 이름을 입력하고 해당 Room에 Join을 요청한다. 이부분은 User A, User B가 같이 사용한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>join.addEventListener("click", function () {

    roomName = roomInput.value;
    socket.emit("join", roomName);
});
</pre></table></code></div></div><p>User A인 경우 Room 을 처음 만드는 것이기 때문에 “created” 신호가 돌아온다. 그 신호를 받아서 userVideo를 설정하고 대기를 한다. 이 상태는 아직 User B가 Join을 하지 않아서 정보의 교환은 없는 상태이다. creator 변수를 true로 설정하여 해당 User가 Room의 생성자인 것을 명시한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>socket.on("created", function (data) {
    console.log("created");
    creator = true;

    navigator.mediaDevices.getUserMedia({
        audio: true,
        video: { width: 1024, height: 640 }
    }).then(function (stream) {
        userStream = stream;
        userVideo.srcObject = stream;
        userVideo.onloadedmetadata = function (e) {
            userVideo.play();
        }
    }).catch(function (err) {
        alert("Couldn't access user media");
    });
});
</pre></table></code></div></div><h2 id="user-b-room-이름을-넣고-join-요청하기">User B, Room 이름을 넣고 Join 요청하기</h2><p>User A에서 입력한 Room 이름과 동일하게 입력하고 Join을 하면 Signaling Server에서는 “joined”가 전달된다. User B의 userVideo를 설정하고 접속 준비가 되었다는 “ready” 정보를 Signaling Server에 전달한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre>socket.on("joined", function () {
    console.log("joined");
    creator = false;

    navigator.mediaDevices.getUserMedia({
        audio: true,
        video: { width: 1024, height: 640 }
    }).then(function (stream) {
        userStream = stream;
        userVideo.srcObject = stream;
        userVideo.onloadedmetadata = function (e) {
            userVideo.play();
        }
        socket.emit("ready", roomName);
    }).catch(function (err) {
        alert("Couldn't access user media");
    });
});
</pre></table></code></div></div><p>Signaling Server에서 “full”이 전달되면 Alert을 표시한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>socket.on("full", function () {
    alert("Room is full");
});
</pre></table></code></div></div><h2 id="user-a-ready를-받고-rtcpeerconnection-생성">User A. ready를 받고 RTCPeerConnection 생성</h2><p>Signaling Server는 “ready”를 Room의 모든 User에 전달을 하지만 이 부분은 creator만 받아서 처리하도록 한다. 그러므로 User A만 처리하게 될 것이다. STUN 혹은 TURN Server 정보를 가지고 RTCPeerConnection 객체를 생성한다.</p><p>먼저 STUN 혹은 TURN Server의 정보를 만든다. 이 튜토리얼에서는 Public Free STUN 서버를 사용해보겠다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>let iceServers = {
    iceServers: [
        { urls: "stun:stun.services.mozilla.com" },
        { urls: "stun:stun.l.google.com:19302" },
    ]
};
</pre></table></code></div></div><p>이제 “ready”에 대한 처리를 해보자. User B에서 보낸 ready는 User A에서만 처리하도록 하였다. creator인 사용자만 처리하도록 하였다. RTCPeerConnection을 생성하면 ICE Candidate 정보를 받아진다. 이 정보를 다른 User에게 전달을 해야되서 oniIceCnadidateFunction에 구현을 하였다. User A에서는 먼저 offer 를 생성해서 User B에게 전달해야한다. Offer와 cadicate가 전달이 완료되면 User A와 User B의 연결이 설정되어 Video, Audio를 서로 Streaming하게 된다. (onTrackFunction)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre>socket.on("ready", function () {
    console.log("ready");
    if (creator) {
        rtcPeerConnection = new RTCPeerConnection(iceServers);
        rtcPeerConnection.onicecandidate = onIceCandidateFunction;
        rtcPeerConnection.ontrack = onTrackFunction;
        rtcPeerConnection.addTrack(userStream.getTracks()[0], userStream);  // audio
        rtcPeerConnection.addTrack(userStream.getTracks()[1], userStream);  // video
        rtcPeerConnection.createOffer()
            .then((offer) =&gt; {
                console.log("createOffer");
                rtcPeerConnection.setLocalDescription(offer);
                socket.emit("offer", offer, roomName);
            })
            .catch((error) =&gt; {
                console.log(error);
            });
    }
});

function onIceCandidateFunction(event) {
    console.log("onIceCandidate");
    if (event.candidate) {
        socket.emit("candidate", event.candidate, roomName);
    }
}

function onTrackFunction(event) {
    console.log("onTrack");

    navigator.mediaDevices.getUserMedia({
        audio: true,
        video: { width: 512, height: 320 }
    }).then(function (stream) {
        peerVideo.srcObject = stream;
        peerVideo.onloadedmetadata = function (e) {
            peerVideo.play();
        }
    }).catch(function (err) {
        alert("Couldn't access user media");
    });

    peerVideo.srcObject = event.streams[0];
    peerVideo.onloadedmetadata = function(e) {
        peerVideo.play();
    }
}

socket.on("candidate", function (candidate) {
    console.log("candidate");
    rtcPeerConnection.addIceCandidate(new RTCIceCandidate(candidate));
});
</pre></table></code></div></div><h2 id="user-b-offer를-받고-rtcpeerconnection-생성">User B. offer를 받고 RTCPeerConnection 생성</h2><p>User A가 보낸 offer를 받으면, RTCPeerConnection 생성한다. User A에서 RTCPeerConnection을 생성할때와 동일하게 STUN Server에서 ICE Candidate를 받아 User A에게 전달을 한다.<br /> offer 정보를 Remote Description에 설정하고 answer를 생성한다. 생성된 answer는 User A에게 전달되도록 한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>socket.on("offer", function (offer) {
    console.log("offer");
    if (!creator) {
        rtcPeerConnection = new RTCPeerConnection(iceServers);
        rtcPeerConnection.onicecandidate = onIceCandidateFunction;
        rtcPeerConnection.ontrack = onTrackFunction;
        rtcPeerConnection.addTrack(userStream.getTracks()[0], userStream);  // audio
        rtcPeerConnection.addTrack(userStream.getTracks()[1], userStream);  // video
        rtcPeerConnection.setRemoteDescription(offer);
        rtcPeerConnection.createAnswer()
            .then((answer) =&gt; {
                console.log("createAnswer");
                rtcPeerConnection.setLocalDescription(answer);
                socket.emit("answer", answer, roomName);
            })
            .catch((error) =&gt; {
                console.log(error);
            });
    }
});
</pre></table></code></div></div><h2 id="user-a-answer를-받고-remotedescription-설정">User A. answer를 받고 remoteDescription 설정</h2><p>User B가 보낸 answer 정보를 User A가 받아서 remoteDescription 을 설정을 한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>socket.on("answer", function (answer) {
    console.log("answer");
    if (creator) {
        rtcPeerConnection.setRemoteDescription(answer);
    }
});
</pre></table></code></div></div><blockquote><p>Note. candidate, offer, answer 정보는 Peer to Peer로 연결하고 Streaming을 위해 필요하다. 이 곳에서는 저장소 없이 상호 정보를 제공하기 위해 조금은 헷갈리는 구조가 되어 있으나. 생성자와 참여자로 구분하여 ICE Candidate, Offer, Answer를 저장소에 저장하여 사용할 수도 있다.</p></blockquote><h1 id="conclusions">Conclusions</h1><p>WebRTC의 기본 연결 방법을 알아봤다. 실제 운영환경에서 다양한 Network, NAT환경을 고려해야할 것 이다. STUN만으로 만될수도 있어 TURN Server을 구성해야할 수도 있을 것이다. User간의 각종 정보를 교환하는 방식또한 상황에따라 본 튜토리얼에서처럼 Signal(Event) 를 서로 전달하면서 할수도 있고 Storage (DB, Memory 등등)를 이용할 수도 있겠다.</p><h1 id="references">References</h1><p><a href="https://learning.oreilly.com/videos/practical-webrtc-a/9781801810012/">Practical WebRTC: A Complete WebRTC Bootcamp for Beginners</a></p><p><a href="https://webrtc.org/getting-started/overview?hl=en">WerRTC Guide</a></p><p><a href="https://socket.io/docs/v4/">Socket.io</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/network/'>Network</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=WebRTC Video Chat 만들기 - Ahnchan&url=https://ahnchan.github.io/posts/WebRTC-basic/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=WebRTC Video Chat 만들기 - Ahnchan&u=https://ahnchan.github.io/posts/WebRTC-basic/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=WebRTC Video Chat 만들기 - Ahnchan&url=https://ahnchan.github.io/posts/WebRTC-basic/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Platform-kafka-quick-start/">Apache Kafka - Quick Start</a><li><a href="/posts/Install-Jupyterhub_on_Microk8s/">Install JupyterHub on Microk8s</a><li><a href="/posts/Install-Airflow_on_Microk8s/">Install Apache Airflow on Microk8s</a><li><a href="/posts/gRPC-basic-java-step1/">gRPC - Java 환경구성하기, Dummy Service 만들기</a><li><a href="/posts/gRPC-basic-java-step2/">gRPC - Greeting Service 만들기</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav><div style="margin-top:20px;"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2304979176656635" crossorigin="anonymous"></script> <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-2304979176656635" data-ad-slot="4120180236" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2304979176656635" crossorigin="anonymous"></script> <ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-2304979176656635" data-ad-slot="1066641487"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/gRPC-basic-java-step1/"><div class="card-body"> <span class="timeago small" > Nov 9, 2021 <i class="unloaded">2021-11-09T16:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>gRPC - Java 환경구성하기, Dummy Service 만들기</h3><div class="text-muted small"><p> created : 2021-11-09, updated : 2021-11-09 Introduction Micro Service의 환경이 되면서 점점 더 Service간의 연계가 많아지면서 서비스가 복잡해지고 있다. REST API 로 스펙관리에 한계를 느끼고 있다고 한다. 그래서 다시금 RPC 개념이 사용되고 있다. 기존 RPC를 Google에서 좀...</p></div></div></a></div><div class="card"> <a href="/posts/gRPC-basic-java-step2/"><div class="card-body"> <span class="timeago small" > Nov 21, 2021 <i class="unloaded">2021-11-21T16:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>gRPC - Greeting Service 만들기</h3><div class="text-muted small"><p> created : 2021-11-21, updated : 2021-11-21 Introduction 이전 튜토리얼에서는 gRPC의 기본 개념과 Protocol Buffer와 Dummy Server/Client를 간단하게 만들어 보았다. 이제는 한단계 더 들어가서 데이터를 통신하는 방식을 알아보겠다. Pre-Installation IntelliJ C...</p></div></div></a></div><div class="card"> <a href="/posts/GraphQL-Spring-GraphQL_M/"><div class="card-body"> <span class="timeago small" > Dec 5, 2021 <i class="unloaded">2021-12-05T16:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>GraphQL - Spring GraphQL (not GA)</h3><div class="text-muted small"><p> created : 2021-12-05, updated : 2021-12-05 Introduction GraphQL은 2015년에 Open Source로 Facebook이 공개하였다. 나는 그 당시는 REST API 위주로 프로젝트를 하고 있어 언젠가는 봐야지하고 미뤄놨던 기술이다. 이번에 Spring GraphQL에 대한 Spring Tips의 동영...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/gRPC-basic-java-step1/" class="btn btn-outline-primary" prompt="Older"><p>gRPC - Java 환경구성하기, Dummy Service 만들기</p></a> <a href="/posts/gRPC-basic-java-step2/" class="btn btn-outline-primary" prompt="Newer"><p>gRPC - Greeting Service 만들기</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://twitter.com/claude_ahn">Chanyoung Ahn</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://ahnchan.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
